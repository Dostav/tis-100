---
layout: page
title: Chapter 4 - Learning about Pipelining
---

## Segment 30647: Sequence Generator

### Optimized for size: 156 cycles, 4 nodes, 17 instructions

[Save file](../save/30647.0.txt)

All the logic is contained in Node 2.

We need to "look at" each input value twice: first for determining which one is larger, then again to create the output stream. Node 1 passes two copies of `IN.A` to Node 2, and Node 2 stores a copy of `IN.B` in `BAK`.

### Optimized for speed: 96 cycles, 7 nodes, 20 instructions

[Save file](../save/30647.1.txt)

In Chapter 3, Sequence Amplifier taught us to speed up a calculation by using multiple nodes to do the same operations on multiple streams of data. Today we'll use multiple nodes to do _different_ operations on the _same_ stream of data.

It wasn't very efficient to have Node 2 doing all the work; in the size-optimized solution, Node 2 is always running while Nodes 6 and 9 are idle almost half the time. We can split its work into three separate tasks.

Node 2 still calculates `IN.B - IN.A`, but instead of using the result to sort the outputs as before, it just passes the result to Node 6 and grabs another input value as soon as possible.

Node 6 puts the outputs in the correct order, and Node 9 adds a `0` onto the end.

After running the program, look at the path from `IN.B` to `OUT`. Node 6 is busiest at 8% idle, but Nodes 2 and 9 are only 17% idle. (The other nodes are less busy, but they're just for plumbing.) By keeping each node about equally busy with its own step in the pipeline, we cut down on the amount of time spent waiting.

For homework, swap the order of the `MOV ACC RIGHT` and `MOV ACC DOWN` instructions in Node 1. What happens? Why?

## Segment 31904: Sequence Counter

### Optimized for speed: 238 cycles, 6 nodes, 22 instructions

[Save file](../save/31904.0.txt)

Node 7 behaves like an extra register for node 8, storing the sum of all the inputs so far.

Node 9 stores its count of inputs in `BAK`. It resets the counter by `SWP`ing in the zero that ends each sequence of numbers.

### Without using SWP: 267 cycles, 7 nodes, 24 instructions.

[Save file](../save/31904.1.txt)

This doesn't take many changes; just use node 10 as an extra register for node 8.

### Optimized for size... without using SWP: 298 cycles, 4 nodes, 19 instructions

[Save file](../save/31904.2.txt)

Solution by [CaitSith2](https://github.com/CaitSith2).

Node 4 decides whether the input is 0 or not.  If it is not 0, the input is passed to Node 8, where it is added, and node 9 gets instructed to increment the ACC. A 0 likewise tells nodes 8 and 9 to output their totals, and reset.  This is done JRO style.

## Segment 32050: Signal Edge Detector

### Optimized for size: 347 cycles, 4 nodes, 14 instructions

[Save file](../save/32050.0.txt)

Node 6 subtracts the current input from the previous input stored in `ACC`, takes the absolute value of the difference, and uses it to determine the output. It then takes a second copy of the current input (generated by node 1) and stores it in `ACC`.

### Optimized for speed: 286 cycles, 6 nodes, 29 instructions

[Save file](../save/32050.1.txt)

Nodes 1, 2, and 5 generate four copies of the current input: two for node 6 and two for node 8. Node 6 checks whether the difference is greater than +10, node 8 checks whether the difference is less than -10, and node 9 computes an OR between nodes 6 and 8.

Note that each node's program _should_ take the same amount of time (5 cycles) unless an edge is detected, so the limiting factor for performance is a pipeline stall in nodes 6 and 8: the `SUB UP` instruction blocks for one cycle while waiting for new input from nodes 2 and 5. Fixing this stall would save 40 cycles (one cycle per input).

For homework:

- Try to predict how many cycles would be wasted by swapping the `SUB 10` and `SUB UP` instructions in node 8.
- Swap the `MOV ACC DOWN` and `MOV ACC RIGHT` instructions in node 1. How many cycles are wasted?
- Can you restore the program's original throughput by changing two additional instructions?

## Segment 33762: Interrupt Handler

### Optimized for speed: 195 cycles, 10 nodes, 44 instructions

[Save file](../save/33762.0.txt)

Finishing touches by [CaitSith2](https://github.com/CaitSith2) and [Solomute](https://github.com/Solomute).

Nodes 0 through 3 output their respective input numbers when their inputs change from zero to one; they output zero for all other conditions. (They are `ARMED` when the previous input was zero, and `DISARMED` when the previous input was one.)

Nodes 5, 6, and 9 collect the outputs from nodes 0 through 3. Since we are guaranteed that two interrupts will never change in the same input cycle, adding the output values together results in the correct value for `OUT`.

### Optimzed for size: 427 cycles, 6 nodes, 40 instructions

[Save file](../save/33762.1.txt)

Solution by [CaitSith2](https://github.com/CaitSith2).

Works much like the optimized for speed solution, ecept that node 0 passes the value to node 1; node 1 passes its value and node 0's value to node 2; node 3 passes its value to node 2; and node 2 passes its value down, along with the values from nodes 0, 1, and 3.  Node 6 then adds up the values and passes the result down.
